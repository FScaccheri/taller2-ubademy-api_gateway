# Introducción

&nbsp;&nbsp;&nbsp;&nbsp;A lo largo de la implementación del trabajo fue realizada una serie de toma de decisiones troncales para el diseño, modelado e implementación de la aplicación. El presente documento trata sobre las decisiones implementadas que terminaron generando problemas más adelante en el proyecto, o elementos que introdujeron retrasos en la implementación. Estas se explicarán a continuación.

# Estructura de los documentos de exámenes

&nbsp;&nbsp;&nbsp;&nbsp;En el momento en el que se comenzó a implementar las funcionalizades relacionadas a los exámenes, se decidió utilizar para el guardado de exámenes en la base de datos una estructura con un array que contenía otras estructuras que contenían arrays, es decir, se tenían arrays anidados (puede verse la figura en la sección de interacción con exámenes de la documentación técnica para mayor claridad). A pesar de que podría no ser considerada una mala elección a la hora de organizar la estructura de un documento para guardar en Mongo, sí generó una gran cantidad de atraso en el desarrollo de las funcionalidades relacionadas a los exámenes.  
&nbsp;&nbsp;&nbsp;&nbsp;Esto se debió a una falta de conocimiento sobre el funcionamiento de las queries de Mongo. Esto generó que los filtrados para la obtención de documentos fuera errónea, considerando que utilizar la función find() retornaba un documento embebido, cuando en realidad retorna todo el documento (junto con los documentos embebidos) de aquellos que cumplan con la condición de filtrado indicada. Esto generó problemas en el fetching de documentosw particulares en estos arrays embebidos, cosas como enunciados de exámenes, exámenes resueltos por estudiantes, etc, no se estaba consiguiendo realmente el documento solicitado, sino todo el documento de exámenes asociado al curso sobre el cual se estaba operando en el momento.  
&nbsp;&nbsp;&nbsp;&nbsp;El constante fallo en las queries de exámenes generó un atraso de aproximadamente 5 días, tiempo en el que se buscaron formas alternativas de solucionar el problema. Finalmente, se decidió realizar una consulta personalizada en stack overflow, que al ser respondida pudo solucionarse el problema, utilizando comandos de agregación de documentos pensados específicamente para el procesamiento de arrays de documentos.  
&nbsp;&nbsp;&nbsp;&nbsp;Puede verse entonces que, a pesar de que la falta de conocimiento del funcionamiento de las quieries de Mongodb es entendible, se debería haber consultado antes del momento seleccionado, ya que eso hubiese acordado considerablemente la cantidad de tiempo perdida.

# Estructura de los usuarios normales y federados

&nbsp;&nbsp;&nbsp;&nbsp;Otro error cometido en el diseño de las bases de datos es aquel relacionado con el login de usuarios normales junto con el federado. En este caso se decidió tener dos tablas casi idénticas, una de usuarios que utilizan una cuenta de Ubademy, y otra de usuarios que utilizan Google para hacer login. La única diferencia entre estas dos tablas es que la de Google no tiene contraseña, ya que el usuario interactuará con Google para generar un token que nos indica que es un usuario verificado, que es quien dice ser.  
&nbsp;&nbsp;&nbsp;&nbsp;A pesar de que este error de diseño no causó significativas pérdidas de tiempo, sí generó posibles bugs para el registro y login de usuarios, y nos obligó a implementar chequeos adicionales en tablas para corroborar que cuando un usuario se registra o loggea de una forma no tenga una cuenta ya existente de la otra, lo cual induce más a introducir errores en la implementación del login. Una posible solución a esto sería que, en vez de diseñar la tabla de usuarios con una columna de contraseña que no acepta NULL, hacer que sí lo acepte, manejar a mano que si un usuario se registra con una cuenta de Ubademy debe proporcionar una contraseña válida, y considerar el caso en el que el usuario tiene NULL en el campo de la contraseña como un usuario que utiliza login federado. Esto nos permitiría no tener la tabla adicional de login, y por lo tanto facilitar el agregado de usuarios normales y búsqueda de usuarios en la app.


# Problemas de configuración

&nbsp;&nbsp;&nbsp;&nbsp;A lo largo del desarrollo de la aplicación, se debió configurar una gran cantidad de programas para que el código generado funcione correctamente. Al ser la mayoría de estas tecnologías previamente desconocidas, se debió gastar mucho tiempo en la configuración para permitir el correcto uso de estas tecnologías. Muchas veces la documentación no fue muy clara, por lo que recurrimos a prueba y error para intentar solucionar los problemas que surgieran. Generalmente esto consumió mucho tiempo, más del que se le debería haber otorgado. Luego de revisar la documentación oficial y probar manualmente, muchas veces encontramos la solución en blogs, documentos, preguntas, etc. de otros usuarios, por lo que podríamos haber recurrido a eso en mayor medida antes que potencialmente malgastar el tiempo intentando configurar algo muy complicado de lograr intuitivamente. Unos ejemplos de problemas de configuración con los que nos encontramos fueron: conectar distintos servicios con docker-compose, el levantado de bases de datos locales utilizando imágenes de docker, problemas en queries de mongo y postgres, configuración del monitoreo, etc.